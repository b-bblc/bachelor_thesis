<rst>
	<header>
		<relations>
			<rel name="antithesis" type="rst" />
			<rel name="attribution" type="rst" />
			<rel name="background" type="rst" />
			<rel name="cause" type="rst" />
			<rel name="comparison" type="multinuc" />
			<rel name="concession" type="rst" />
			<rel name="conclusion" type="rst" />
			<rel name="condition" type="rst" />
			<rel name="contrast" type="multinuc" />
			<rel name="effect" type="rst" />
			<rel name="elaboration" type="rst" />
			<rel name="evaluation" type="rst" />
			<rel name="evidence" type="rst" />
			<rel name="joint" type="multinuc" />
			<rel name="motivation" type="rst" />
			<rel name="preparation" type="rst" />
			<rel name="purpose" type="rst" />
			<rel name="restatement" type="multinuc" />
			<rel name="same-unit" type="multinuc" />
			<rel name="sequence" type="multinuc" />
			<rel name="solutionhood" type="rst" />
		</relations>
	</header>
	<body>
		<segment id="1" relname="antithesis">﻿УДК 004.89</segment>
		<segment id="2" parent="215" relname="span">ВЕРИФИКАЦИЯ ДАННЫХ В СИСТЕМАХ ОТСЛЕЖИВАНИЯ ЗАДАЧ С ПОМОЩЬЮ ПРОДУКЦИОННЫХ ПРАВИЛ</segment>
		<segment id="3" parent="2" relname="attribution">Р.С. Катериненко, И.А. Бессмертный</segment>
		<segment id="4" relname="antithesis">Предлагается методика верификации данных в системах отслеживания задач с помощью модели продукционных правил. Данная модель позволяет в декларативном стиле формулировать условия, которым должно соответствовать информационное наполнение, и использовать логический вывод. В качестве практических результатов описывается применение разработанной системы верификации для реального проекта разработки программного обеспечения. Ключевые слова: продукционные правила, логический вывод, системы отслеживания задач, верификация.</segment>
		<segment id="5" parent="451" relname="preparation">Введение</segment>
		<segment id="6" parent="370" relname="span">Система отслеживания задач (СОЗ) - прикладная программа, разработанная с целью</segment>
		<segment id="7" parent="6" relname="purpose">помочь контролировать ход отдельных задач и проекта в целом.</segment>
		<segment id="8" parent="372" relname="joint">Основные компоненты такой системы - это база данных задач и графический интерфейс с возможностью редактирования задач и построения аналитических отчетов.</segment>
		<segment id="9" parent="10" relname="cause">Информация в подобной системе меняется и используется большим количеством специалистов из разных областей,</segment>
		<segment id="10" parent="218" relname="span">что является одним из источников ошибок.</segment>
		<segment id="11" parent="12" relname="concession">Какой бы хорошей ни была СОЗ,</segment>
		<segment id="12" parent="217" relname="span">со временем эксплуатации в содержащейся информации накапливаются неточности, противоречия, ошибки.</segment>
		<segment id="13" parent="217" relname="cause">Этому способствуют человеческий фактор и неточность естественного языка.</segment>
		<segment id="14" parent="219" relname="elaboration">В свою очередь, от адекватного состояния информационного наполнения зависят продуктивность работы участников проекта и его успех.</segment>
		<segment id="15" parent="16" relname="cause">Другой проблемой является миграция неточностей из базы СОЗ в автоматически генерируемые отчеты.</segment>
		<segment id="16" parent="221" relname="span">Неправильные данные в таких отчетах могут привести к неверно подсчитанным трудозатратам, финансовым затратам и ошибочному планированию.</segment>
		<segment id="17" parent="379" relname="preparation">В основном СОЗ создаются под каждый отдельно взятый проект на базе общей платформы СОЗ.</segment>
		<segment id="18" parent="364" relname="span">Платформа для создания СОЗ имеет язык высокого уровня абстракций,</segment>
		<segment id="19" parent="222" relname="joint">подходящий для описания широкого круга проектов в терминах рабочего процесса, артефактов рабочего процесса, связей между артефактами, состояний артефактов и т.д.</segment>
		<segment id="20" parent="222" relname="joint">Из-за высокой универсальности этот язык позволяет реализовать только основные проверки целостности информации на уровне правильности заполнения полей артефактов.</segment>
		<segment id="21" parent="364" relname="elaboration">Его возможности ограничиваются синтаксическими проверками.</segment>
		<segment id="22" parent="420" relname="span">Авторы предлагают использовать</segment>
		<segment id="23" parent="22" relname="purpose">для целей верификации информационного наполнения СОЗ</segment>
		<segment id="24" parent="421" relname="same-unit">логические правила - продукции.</segment>
		<segment id="25" parent="227" relname="joint">Преимущества продукционного языка - декларативность и язык запросов, основанный на логическом выводе.</segment>
		<segment id="26" parent="365" relname="span">Продукционный язык обладает большими выразительными возможностями,</segment>
		<segment id="27" parent="26" relname="purpose">позволяющими формулировать сложные ограничения на семантику информации в СОЗ, в том числе рекурсивные правила.</segment>
		<segment id="28" parent="250" relname="preparation">Модель продукционных правил</segment>
		<segment id="29" parent="231" relname="span">Модель продукционных правил относится к классу дедуктивных логических систем,</segment>
		<segment id="30" parent="29" relname="elaboration">в основе которых лежит принцип дедукции - порождение истинных фактов из заданных аксиом и правил.</segment>
		<segment id="31" parent="232" relname="joint">В общем случае дедуктивная система состоит из набора аксиом, правил вывода и изначально заданных формул.</segment>
		<segment id="32" parent="235" relname="purpose">В модели продукционных правил с целью повышения эффективности логического вывода</segment>
		<segment id="33" parent="235" relname="span">введены ограничения:</segment>
		<segment id="34" parent="233" relname="joint">\- правила вывода (продукционные правила) являются хорновскими выражениями;</segment>
		<segment id="35" parent="233" relname="joint">\- факты представляют собой атомарные формулы.</segment>
		<segment id="36" parent="386" relname="preparation">Хорновское выражение (horn clause) - это дизъюнкция литералов с одним единственным положительным литералом.</segment>
		<segment id="37" parent="236" relname="comparison">Литералом называется атомарная формула,</segment>
		<segment id="38" parent="236" relname="comparison">а атомарная формула с отрицанием называется отрицательным литералом.</segment>
		<segment id="39" parent="237" relname="span">Если применить эквивалентность</segment>
		<segment id="40" parent="39" relname="elaboration">[формула],</segment>
		<segment id="41" parent="238" relname="span">то хорновский дизъюнкт превращается в привычный вид импликации или продукции:</segment>
		<segment id="42" parent="41" relname="elaboration">[формула].</segment>
		<segment id="43" parent="423" relname="preparation">В некоторых продукционных системах поддерживаются рекурсивные правила, отрицание по «принципу закрытого мира» и термы-функции.</segment>
		<segment id="44" parent="45" relname="attribution">Согласно «принципу закрытого мира» (closed world assumption)</segment>
		<segment id="45" parent="241" relname="span">все те факты, которые не заложены в систему и не могут быть получены логическим выводом, объявляются ложными.</segment>
		<segment id="46" parent="242" relname="restatement">Другими словами, все, о чем нет информации в системе, объявляется ложным.</segment>
		<segment id="47" parent="245" relname="span">Преимуществами указанного типа моделей являются:</segment>
		<segment id="48" parent="244" relname="joint">\- простота и ясность основной единицы - продукционного правила;</segment>
		<segment id="49" parent="244" relname="joint">\- независимость продукций и легкость модификации баз знаний;</segment>
		<segment id="50" parent="244" relname="joint">\- строгость, простота и изученность механизма логического вывода;</segment>
		<segment id="51" parent="244" relname="joint">\- эффективность логического вывода.</segment>
		<segment id="52" parent="247" relname="span">К недостаткам можно отнести:</segment>
		<segment id="53" parent="246" relname="joint">\- малую степень структурированности базы знаний;</segment>
		<segment id="54" parent="246" relname="joint">\- неуниверсальность.</segment>
		<segment id="55" relname="antithesis">Р.С. Катериненко, И.А. Бессмертный</segment>
		<segment id="56" parent="290" relname="preparation">Применение модели продукционных правил</segment>
		<segment id="57" parent="58" relname="purpose">Как было показано выше, для построения логической модели</segment>
		<segment id="58" parent="428" relname="span">необходимы изначально заданные факты и правила.</segment>
		<segment id="59" parent="253" relname="joint">Часть информации СОЗ, подлежащая верификации, должна быть представлена в виде фактов для формирования предикатов.</segment>
		<segment id="60" parent="254" relname="span">Правилами здесь являются записанные на продукционном языке свойства,</segment>
		<segment id="61" parent="60" relname="condition">которым должны удовлетворять данные.</segment>
		<segment id="62" parent="253" relname="joint">Проверка того, что данные СОЗ удовлетворяют заданным правилам, называется верификацией СОЗ.</segment>
		<segment id="63" parent="390" relname="preparation">Рассмотрим предлагаемую методику на примере СОЗ, эксплуатируемой в проекте разработки программного обеспечения длительностью 10 лет.</segment>
		<segment id="64" parent="390" relname="span">Основными артефактами являются спецификации, тикеты, проекты.</segment>
		<segment id="65" parent="392" relname="span">Тикетом будем называть представление задачи в СОЗ.</segment>
		<segment id="66" parent="256" relname="span">Тикет является минимальной атомарной единицей информации о задаче.</segment>
		<segment id="67" parent="66" relname="elaboration">В данном примере одной задаче соответствует один тикет.</segment>
		<segment id="68" parent="391" relname="joint">В проекте может быть произвольное число тикетов и спецификаций, связанных между собой различными связями.</segment>
		<segment id="69" parent="258" relname="span">Тикет бывает следующих видов:</segment>
		<segment id="70" parent="257" relname="joint">\- описание дефекта;</segment>
		<segment id="71" parent="257" relname="joint">\- описание задачи для разработки;</segment>
		<segment id="72" parent="257" relname="joint">\- описание исследовательской задачи;</segment>
		<segment id="73" parent="257" relname="joint">\- описание дизайнерской задачи; и т. д.</segment>
		<segment id="74" parent="395" relname="preparation">У тикета имеется около 30 обязательных и необязательных для заполнения полей.</segment>
		<segment id="75" parent="395" relname="span">Помимо полей, у тикета есть именованные связи с другими тикетами.</segment>
		<segment id="76" parent="429" relname="joint">Связи представляют собой ссылки от одного тикета к другому</segment>
		<segment id="77" parent="429" relname="joint">и могут иметь следующие типы: «has clone», «duplicates», «introduces», «incorporates», «relates».</segment>
		<segment id="78" parent="260" relname="comparison">Симметричными им являются соответственно: «clone of», «is duplicated by», «introduced by», «is incorporated by», «is related to».</segment>
		<segment id="79" parent="261" relname="joint">Семантика связей следует из англоязычных названий связей</segment>
		<segment id="80" parent="261" relname="joint">и не является существенной для раскрытия содержания темы,</segment>
		<segment id="81" parent="262" relname="span">поэтому выходит за рамки настоящей работы.</segment>
		<segment id="82" parent="270" relname="span">Существенная для верификации информация экспортируется из системы отслеживания задач (СОЗ) в предикаты следующим образом.</segment>
		<segment id="83" parent="267" relname="span">\- Каждому полю тикета сопоставляется двухместный предикат тикет-значение.</segment>
		<segment id="84" parent="265" relname="condition">Например, если тикет № 8520 имеет поле «Номер спецификации» («requirement»), равное 328,</segment>
		<segment id="85" parent="265" relname="span">то соответствующий предикат будет иметь вид hasRequirement(T1,T2):</segment>
		<segment id="86" parent="85" relname="elaboration">hasRequirement(8520, 328) = true.</segment>
		<segment id="87" parent="425" relname="span">\- Каждому типу связи ставится в соответствие двухместный предикат тикет- тикет.</segment>
		<segment id="88" parent="87" relname="elaboration">Например, двум тикетам, связанным связью вида «introduces», будет соответствовать предикат вида introduces(T1, T2).</segment>
		<segment id="89" parent="426" relname="span">Свойства, которым должно удовлетворять информационное наполнение системы, формулируются в виде продукционных правил.</segment>
		<segment id="90" parent="427" relname="span">В нашей системе одним из правил было наличие у каждого тикета ссылки (связи) на спецификацию, под которой по нему велись работы.</segment>
		<segment id="91" parent="92" relname="condition">Если тикет был причиной других тикетов,</segment>
		<segment id="92" parent="274" relname="span">то спецификация должна была наследоваться.</segment>
		<segment id="93" parent="94" relname="condition">При составлении биллинговых отчетов</segment>
		<segment id="94" parent="430" relname="span">часы, затраченные на выполнение спецификации, брались как сумма часов по связанным с ней тикетам.</segment>
		<segment id="95" parent="275" relname="joint">Нарушение указанного правила приводило к большим расходам.</segment>
		<segment id="96" parent="272" relname="preparation">Сформулируем это ограничение в виде правил - продукций:</segment>
		<segment id="97" parent="271" relname="joint">introducesClosure(T1, T2) :— introduces(T1, T2) (1)</segment>
		<segment id="98" parent="271" relname="joint">introducesClosure(T1, T3) :— introduces(T1, T2), introducesClosure(T2, T3) (2)</segment>
		<segment id="99" parent="271" relname="joint">requirementForClosure(R, T2) :— requirementFor(R, T1), introducesClosure(T1, T2) (3)</segment>
		<segment id="100" parent="287" relname="sequence">Правила (1) и (2) определяют предикат introducesClosure как транзитивное замыкание по свойству «introduces».</segment>
		<segment id="101" parent="288" relname="span">После выполнения логического вывода он должен содержать все пары тикетов,</segment>
		<segment id="102" parent="103" relname="cause">первый из которых</segment>
		<segment id="103" parent="280" relname="span">является причиной возникновения второго.</segment>
		<segment id="104" parent="281" relname="span">Правило (2) задает предикат requirementClosure, который должен содержать все пары вида спецификация-тикет,</segment>
		<segment id="105" parent="104" relname="condition">учитывая наследование спецификаций.</segment>
		<segment id="106" parent="107" relname="condition">Эти три правила ((1)-(3)) задают условие,</segment>
		<segment id="107" parent="282" relname="span">которому должно соответствовать правильное информационное наполнение.</segment>
		<segment id="108" parent="285" relname="cause">Но в реальной системе всегда содержатся ошибки.</segment>
		<segment id="109" parent="285" relname="span">В связи с этим следующим шагом является написание диагностического правила:</segment>
		<segment id="110" parent="109" relname="elaboration">failRequirement(R, T) :— requirementForClosure(R, T), not requirementFor(R, T) (4)</segment>
		<segment id="111" parent="294" relname="span">Предикат failRequirement должен содержать те пары вида спецификация-тикет,</segment>
		<segment id="112" parent="293" relname="contrast">которых не было в системе,</segment>
		<segment id="113" parent="292" relname="span">но которые должны в ней быть,</segment>
		<segment id="114" parent="113" relname="condition">следуя описанным ограничениям.</segment>
		<segment id="115" parent="295" relname="cause">Исходя из этого,</segment>
		<segment id="116" parent="295" relname="span">срабатывание данного правила соответствует ошибочной ситуации,</segment>
		<segment id="117" parent="116" relname="condition">когда в СОЗ у тикета T не проставлена спецификация R.</segment>
		<segment id="118" parent="367" relname="span">После верификации информационное наполнение может быть скорректировано администратором СОЗ таким образом,</segment>
		<segment id="119" parent="118" relname="purpose">чтобы диагностические предикаты стали «пустыми» после следующей итерации.</segment>
		<segment id="120" parent="432" relname="preparation">Общий алгоритм верификации</segment>
		<segment id="121" parent="431" relname="span">На рис. 1 в схематическом виде приведены основные этапы алгоритма верификации и данные, передаваемые между ними.</segment>
		<segment id="122" parent="123" relname="preparation">1\. Выгрузка данных.</segment>
		<segment id="123" parent="301" relname="span">На этом этапе происходит выгрузка данных из СОЗ в виде отчетов, результатов выполнения SQL-запросов или html-страниц.</segment>
		<segment id="124" parent="125" relname="preparation">2\. Преобразование.</segment>
		<segment id="125" parent="302" relname="span">Из выгруженных данных формируется логическая модель: предикаты, домены (области определения аргументов предиката).</segment>
		<segment id="126" parent="127" relname="preparation">3\. Логический вывод.</segment>
		<segment id="127" parent="303" relname="span">К логической модели добавляются продукционные правила для верификации (1), (2), (3) и вспомогательные диагностические продукционные правила (4) для локализации ошибочной информации.</segment>
		<segment id="128" parent="129" relname="preparation">4\. Коррекция данных.</segment>
		<segment id="129" parent="304" relname="span">На данном шаге аналитик или администратор системы должен исправить ошибочную информацию, указанную в диагностических предикатах.</segment>
		<segment id="130" parent="399" relname="span">Отчеты Домены</segment>
		<segment id="131" parent="130" relname="elaboration">[Рис. 1. Основные этапы алгоритма верификации]</segment>
		<segment id="132" parent="310" relname="joint">Описанная итерация может быть проделана несколько раз по мере добавления диагностических правил и коррекции информации.</segment>
		<segment id="133" parent="309" relname="span">Информация считается верифицированной,</segment>
		<segment id="134" parent="133" relname="condition">когда все диагностические предикаты пусты.</segment>
		<segment id="135" parent="325" relname="preparation">Описание программной реализации</segment>
		<segment id="136" parent="311" relname="span">На рис. 2 приведена схема модулей программной реализации.</segment>
		<segment id="137" parent="136" relname="elaboration">[Рис. 2. Схема модулей программной реализации]</segment>
		<segment id="138" parent="403" relname="preparation">Основными модулями являются: модуль выгрузки данных, модуль построения логической модели и модуль логического вывода.</segment>
		<segment id="139" parent="401" relname="span">Функционал модуля выгрузки данных заключается в извлечении верифицируемых данных из СОЗ.</segment>
		<segment id="140" parent="313" relname="contrast">В данном случае взаимодействие с СОЗ, построенной на программной платформе JIRA, осуществляется по протоколу HTTP,</segment>
		<segment id="141" parent="313" relname="contrast">но может быть реализовано непосредственно через базу данных СОЗ и программное API.</segment>
		<segment id="142" parent="314" relname="span">Выгрузка данных может быть полной,</segment>
		<segment id="143" parent="142" relname="condition">когда каждый раз выгружаются все необходимые для верификации данные,</segment>
		<segment id="144" parent="315" relname="span">или инкрементальной,</segment>
		<segment id="145" parent="144" relname="condition">когда добавляются только новые данные.</segment>
		<segment id="146" parent="317" relname="span">Полученные данные в виде файлов поступают на вход модуля построения логической модели,</segment>
		<segment id="147" parent="146" relname="elaboration">где формируются домены и предикаты.</segment>
		<segment id="148" parent="404" relname="span">В нашем приложении этот модуль позволяет декларативно задать правила для преобразования данных в предикаты.</segment>
		<segment id="149" parent="148" relname="elaboration">При этом домены создаются автоматически.</segment>
		<segment id="150" relname="antithesis">P.C. Катериненко, И.А. Бессмертный</segment>
		<segment id="151" parent="439" relname="preparation">Построенная логическая модель и логическая программа, состоящая из продукционных правил, поступают на вход модуля логического вывода.</segment>
		<segment id="152" parent="434" relname="background">Существуют разные подходы для осуществления логического вывода на продукционных правилах.</segment>
		<segment id="153" parent="361" relname="span">Авторами был выбран подход на основе двоичных диаграмм решений (ДДР, Binary Decision Diagram),</segment>
		<segment id="154" parent="153" relname="cause">поскольку авторы ведут исследования в области применения ДДР для логического вывода [1-3].</segment>
		<segment id="155" parent="368" relname="span">ДДР - это структура данных, хорошо зарекомендовавшая себя на практике в области верификации аппаратных средств,</segment>
		<segment id="156" parent="155" relname="purpose">позволяющая выполнять манипуляции над булевыми формулами.</segment>
		<segment id="157" parent="437" relname="span">Компактность и эффективность операций над ДДР может быть использована для представления отношений и быстрого логического вывода [4-6].</segment>
		<segment id="158" parent="323" relname="span">В этом модуле последовательно выполняются следующие шаги:</segment>
		<segment id="159" parent="322" relname="sequence">1\. кодирование доменов и предикатов числами;</segment>
		<segment id="160" parent="322" relname="sequence">2\. построение ДДР;</segment>
		<segment id="161" parent="322" relname="sequence">3\. логический вывод над ДДР;</segment>
		<segment id="162" parent="322" relname="sequence">4\. декодирование ДДР.</segment>
		<segment id="163" parent="322" relname="sequence">Заключительным шагом является осуществление коррекции информации в СОЗ.</segment>
		<segment id="164" parent="412" relname="preparation">Основные результаты</segment>
		<segment id="165" parent="328" relname="span">Мы провели сравнительный эксперимент на реальной СОЗ для нашей задачи,</segment>
		<segment id="166" parent="165" relname="attribution">описанной в разделе «Применение модели продукционных правил».</segment>
		<segment id="167" parent="405" relname="joint">К моменту начала логического вывода в базе данных содержалось 4667 факта и 6 продукционных правил.</segment>
		<segment id="168" parent="405" relname="joint">В качестве системы для сравнения была выбрана система DES (Datalog Educational System), не использующая ДДР.</segment>
		<segment id="169" parent="440" relname="span">Результаты эксперимента приведены в таблице.</segment>
		<segment id="170" parent="331" relname="span">Время указано в миллисекундах.</segment>
		<segment id="171" parent="330" relname="joint">Tl - время загрузки фактов в систему DES.</segment>
		<segment id="172" parent="330" relname="joint">T2 - время логического вывода в системе DES.</segment>
		<segment id="173" parent="330" relname="joint">T3 - время загрузки фактов в нашу систему.</segment>
		<segment id="174" parent="445" relname="span">По сравнению с DES, в нашей системе можно получить отдельно время логического вывода и отдельно время записи его результата в файл или выдачи на экран.</segment>
		<segment id="175" parent="174" relname="elaboration">Этими временами являются T4 и T5 соответственно.</segment>
		<segment id="176" parent="334" relname="joint">Для сравнения производительности логического вывода берутся времена получения ответа от систем с уже загруженными фактами - T2 и T6.</segment>
		<segment id="177" parent="334" relname="joint">Как видно, T2 превосходит T6 более чем в 200 раз.</segment>
		<segment id="178" parent="411" relname="span">Таким образом, наша система на основе ДДР осуществляет логический вывод в 200 раз быстрее DES.</segment>
		<segment id="179" parent="410" relname="joint">Загрузка фактов осуществляется быстрее в 1,4 раза.</segment>
		<segment id="180" parent="410" relname="joint">Система реализована на языке Java.</segment>
		<segment id="181" parent="337" relname="joint">Верифицируемая СОЗ создана с помощью системы JIRA.</segment>
		<segment id="182" parent="338" relname="span">Эксперимент проводился на платформе со следующими характеристиками:</segment>
		<segment id="183" parent="182" relname="elaboration">Intel Core I5 2.3 ГГц, 4 Гб ОЗУ, Windows 7 64-bit, Java 1.6.0_25.</segment>
		<segment id="184" parent="339" relname="joint">Количество фактов</segment>
		<segment id="185" parent="339" relname="joint">Время логического вывода, в мс DES T DES T2 ДДР T3 ДДР T4 ДДР T5 ДДР T6 = T4 + T5 4667 1001 130000 721 311 233 544</segment>
		<segment id="186" parent="340" relname="span">Таблица. Времена логического вывода</segment>
		<segment id="187" parent="416" relname="preparation">В данной работе получен опыт применения продукционной модели и разрабатываемого механизма логического вывода на реальной прикладной задаче.</segment>
		<segment id="188" parent="189" relname="attribution">Авторы считают,</segment>
		<segment id="189" parent="341" relname="span">что создание базы знаний не является очень трудоемкой задачей,</segment>
		<segment id="190" parent="341" relname="cause">потому что может быть легко автоматизировано.</segment>
		<segment id="191" parent="348" relname="joint">Как правило, все СОЗ представляют исходные данные, необходимые для верификации,</segment>
		<segment id="192" parent="348" relname="joint">некоторым регулярным для всех проектов образом.</segment>
		<segment id="193" parent="349" relname="joint">Разработанный единожды модуль выгрузки данных под конкретную СОЗ может быть использован на протяжении всей эксплуатации системы без особых изменений.</segment>
		<segment id="194" parent="349" relname="joint">Построение логической модели и дедуктивный вывод осуществляются автоматически разработанной системой.</segment>
		<segment id="195" parent="349" relname="joint">Участие аналитика требуется лишь при коррекции исходных данных по результатам вывода и формулировки правил для верификации.</segment>
		<segment id="196" parent="351" relname="joint">Выразительность продукционной модели варьируется в зависимости от ее свойств.</segment>
		<segment id="197" parent="448" relname="same-unit">Решаемая задача дала возможность выделить свойства продукционного языка,</segment>
		<segment id="198" parent="449" relname="span">которые должны поддерживаться механизмом вывода</segment>
		<segment id="199" parent="198" relname="purpose">для широкого применения на практике в подобного рода прикладных задачах: поддержка отрицания, рекурсии, временных предикатов, функций для работы со строками и числами.</segment>
		<segment id="200" parent="359" relname="preparation">Заключение</segment>
		<segment id="201" parent="419" relname="preparation">Предложенный подход может быть реализован в виде отдельного приложения для верификации систем отслеживания задач или в качестве плагина к системе отслеживания задач.</segment>
		<segment id="202" parent="352" relname="joint">В результате применения были обнаружены и скорректированы ошибки в информационном наполнении в эксплуатируемой системе.</segment>
		<segment id="203" parent="353" relname="joint">Выбранный метод логического вывода на основе двоичных диаграмм решений показал хорошую производительность</segment>
		<segment id="204" parent="353" relname="joint">и имеет большой запас по производительности.</segment>
		<segment id="205" parent="357" relname="span">На взгляд авторов, методику имеет смысл применять в проектах при выполнении двух условий:</segment>
		<segment id="206" relname="antithesis">АГЛОМЕРАТИВНАЯ КЛАСТЕРИЗАЦИЯ РЕЧЕВЫХ СЕГМЕНТОВ ФОНОГРАММЫ..</segment>
		<segment id="207" parent="369" relname="span">1\. над проектом работает достаточно большое количество специалистов разных областей,</segment>
		<segment id="208" parent="207" relname="purpose">что способствует быстрому накоплению ошибок в системе отслеживания задач;</segment>
		<segment id="209" parent="443" relname="joint">2\. актуальность и корректность данных в системе отслеживания задач напрямую влияет на ключевые характеристики проекта, такие как трудозатраты,</segment>
		<segment id="210" parent="443" relname="joint">или влияет на качество и работоспособность производимого продукта.</segment>
		<segment id="211" relname="antithesis">Работа выполнена при финансовой поддержке ФЦП «Научные и научно-педагогические кадры инновационной России» на 2009-2013 годы (соглашение № 14.B37.21.0406).</segment>
		<segment id="212" parent="213" relname="preparation">Литература</segment>
		<segment id="213" relname="antithesis">1\. Bessmertny I.A., Katerinenko R.S. The method of acceleration of logical inference in production knowledge model // Programming and Computer Software. - Springer, 2011. - V. 37. - № 4. - P. 197-199. 2\. Бессмертный И.А. Теоретико-множественный подход к логическому выводу в базах знаний // Научно-технический вестник СПбГУ ИТМО. 2010. - № 2 (66). - С. 43-48. 3\. Бессмертный И.А. Быстрый логический вывод в среде программирования Visual Prolog // Научно-технический вестник СПбГУ ИТМО. - 2010. - № 3 (67). - С. 50-56. 4\. Iwaihara M., Inoue Y. Bottom-up Evaluation of Logic Programs Using Binary Decision Diagrams // Proc. 11th Int. Conf. Data Engineering. - Taipei, Taiwan, Mar. 1995. - P. 467-474. 5\. Bryant R. Graph-based Algorithms for Boolean Function Manipulation // IEEE Transactions on Computers. - August 1986. - V. 35. - № 8. - P. 677-691. 6\. Andersen H.R. An Introduction to Binary Decision Diagrams // Lecture notes for Advanced Algorithms. -Lyngby, Denmark, 1997. - P. 1-37.</segment>
		<group id="215" type="span" relname="antithesis"/>
		<group id="217" type="span" parent="219" relname="span"/>
		<group id="218" type="span" parent="375" relname="span"/>
		<group id="219" type="span" parent="371" relname="span"/>
		<group id="220" type="multinuc" parent="374" relname="span"/>
		<group id="221" type="span" parent="220" relname="joint"/>
		<group id="222" type="multinuc" parent="18" relname="purpose"/>
		<group id="227" type="multinuc" parent="380" relname="span"/>
		<group id="231" type="span" parent="232" relname="joint"/>
		<group id="232" type="multinuc" parent="249" relname="joint"/>
		<group id="233" type="multinuc" parent="33" relname="elaboration"/>
		<group id="235" type="span" parent="366" relname="span"/>
		<group id="236" type="multinuc" parent="384" relname="span"/>
		<group id="237" type="span" parent="238" relname="condition"/>
		<group id="238" type="span" parent="239" relname="span"/>
		<group id="239" type="span" parent="240" relname="joint"/>
		<group id="240" type="multinuc" parent="386" relname="span"/>
		<group id="241" type="span" parent="242" relname="restatement"/>
		<group id="242" type="multinuc" parent="422" relname="span"/>
		<group id="244" type="multinuc" parent="47" relname="elaboration"/>
		<group id="245" type="span" parent="248" relname="comparison"/>
		<group id="246" type="multinuc" parent="52" relname="elaboration"/>
		<group id="247" type="span" parent="248" relname="comparison"/>
		<group id="248" type="multinuc" parent="422" relname="evaluation"/>
		<group id="249" type="multinuc" parent="250" relname="span"/>
		<group id="250" type="span" parent="251" relname="span"/>
		<group id="251" type="span" relname="antithesis"/>
		<group id="253" type="multinuc" parent="289" relname="joint"/>
		<group id="254" type="span" parent="253" relname="joint"/>
		<group id="256" type="span" parent="391" relname="joint"/>
		<group id="257" type="multinuc" parent="69" relname="elaboration"/>
		<group id="258" type="span" parent="391" relname="joint"/>
		<group id="260" type="multinuc" parent="394" relname="joint"/>
		<group id="261" type="multinuc" parent="81" relname="evidence"/>
		<group id="262" type="span" parent="394" relname="joint"/>
		<group id="265" type="span" parent="266" relname="span"/>
		<group id="266" type="span" parent="83" relname="elaboration"/>
		<group id="267" type="span" parent="269" relname="joint"/>
		<group id="268" type="span" parent="269" relname="joint"/>
		<group id="269" type="multinuc" parent="82" relname="elaboration"/>
		<group id="270" type="span" parent="289" relname="joint"/>
		<group id="271" type="multinuc" parent="272" relname="span"/>
		<group id="272" type="span" parent="273" relname="span"/>
		<group id="273" type="span" parent="279" relname="span"/>
		<group id="274" type="span" parent="90" relname="elaboration"/>
		<group id="275" type="multinuc" parent="277" relname="span"/>
		<group id="277" type="span" parent="278" relname="span"/>
		<group id="278" type="span" parent="273" relname="evidence"/>
		<group id="279" type="span" parent="425" relname="elaboration"/>
		<group id="280" type="span" parent="101" relname="elaboration"/>
		<group id="281" type="span" parent="287" relname="sequence"/>
		<group id="282" type="span" parent="283" relname="contrast"/>
		<group id="283" type="multinuc" parent="287" relname="sequence"/>
		<group id="285" type="span" parent="397" relname="span"/>
		<group id="286" type="span" parent="283" relname="contrast"/>
		<group id="287" type="multinuc" parent="289" relname="joint"/>
		<group id="288" type="span" parent="287" relname="sequence"/>
		<group id="289" type="multinuc" parent="290" relname="span"/>
		<group id="290" type="span" parent="291" relname="span"/>
		<group id="291" type="span" relname="antithesis"/>
		<group id="292" type="span" parent="293" relname="contrast"/>
		<group id="293" type="multinuc" parent="111" relname="elaboration"/>
		<group id="294" type="span" parent="398" relname="span"/>
		<group id="295" type="span" parent="296" relname="span"/>
		<group id="296" type="span" parent="294" relname="elaboration"/>
		<group id="301" type="span" parent="305" relname="sequence"/>
		<group id="302" type="span" parent="305" relname="sequence"/>
		<group id="303" type="span" parent="305" relname="sequence"/>
		<group id="304" type="span" parent="305" relname="sequence"/>
		<group id="305" type="multinuc" parent="306" relname="span"/>
		<group id="306" type="span" parent="432" relname="span"/>
		<group id="307" type="span" relname="antithesis"/>
		<group id="309" type="span" parent="310" relname="joint"/>
		<group id="310" type="multinuc" parent="306" relname="elaboration"/>
		<group id="311" type="span" parent="326" relname="preparation"/>
		<group id="312" type="multinuc" parent="403" relname="span"/>
		<group id="313" type="multinuc" parent="139" relname="elaboration"/>
		<group id="314" type="span" parent="316" relname="same-unit"/>
		<group id="315" type="span" parent="316" relname="same-unit"/>
		<group id="316" type="multinuc" parent="312" relname="joint"/>
		<group id="317" type="span" parent="318" relname="joint"/>
		<group id="318" type="multinuc" parent="324" relname="joint"/>
		<group id="319" type="multinuc" parent="439" relname="span"/>
		<group id="322" type="multinuc" parent="158" relname="elaboration"/>
		<group id="323" type="span" parent="157" relname="elaboration"/>
		<group id="324" type="multinuc" parent="326" relname="span"/>
		<group id="325" type="span" parent="327" relname="span"/>
		<group id="326" type="span" parent="325" relname="span"/>
		<group id="327" type="span" relname="antithesis"/>
		<group id="328" type="span" parent="406" relname="span"/>
		<group id="330" type="multinuc" parent="170" relname="elaboration"/>
		<group id="331" type="span" parent="440" relname="elaboration"/>
		<group id="334" type="multinuc" parent="445" relname="elaboration"/>
		<group id="336" type="span" parent="412" relname="span"/>
		<group id="337" type="multinuc" parent="178" relname="elaboration"/>
		<group id="338" type="span" parent="337" relname="joint"/>
		<group id="339" type="multinuc" parent="186" relname="elaboration"/>
		<group id="340" type="span" parent="169" relname="elaboration"/>
		<group id="341" type="span" parent="362" relname="span"/>
		<group id="345" type="multinuc" parent="416" relname="span"/>
		<group id="348" type="multinuc" parent="349" relname="joint"/>
		<group id="349" type="multinuc" parent="442" relname="span"/>
		<group id="351" type="multinuc" parent="345" relname="joint"/>
		<group id="352" type="multinuc" parent="419" relname="span"/>
		<group id="353" type="multinuc" parent="352" relname="joint"/>
		<group id="357" type="span" parent="358" relname="joint"/>
		<group id="358" type="multinuc" parent="359" relname="span"/>
		<group id="359" type="span" parent="360" relname="span"/>
		<group id="360" type="span" relname="antithesis"/>
		<group id="361" type="span" parent="434" relname="span"/>
		<group id="362" type="span" parent="442" relname="preparation"/>
		<group id="364" type="span" parent="378" relname="span"/>
		<group id="365" type="span" parent="227" relname="joint"/>
		<group id="366" type="span" parent="232" relname="joint"/>
		<group id="367" type="span" parent="287" relname="sequence"/>
		<group id="368" type="span" parent="436" relname="span"/>
		<group id="369" type="span" parent="444" relname="joint"/>
		<group id="370" type="span" parent="372" relname="joint"/>
		<group id="371" type="span" parent="220" relname="joint"/>
		<group id="372" type="multinuc" parent="377" relname="span"/>
		<group id="373" type="span" parent="450" relname="joint"/>
		<group id="374" type="span" parent="373" relname="span"/>
		<group id="375" type="span" parent="374" relname="preparation"/>
		<group id="376" type="span" parent="218" relname="background"/>
		<group id="377" type="span" parent="376" relname="span"/>
		<group id="378" type="span" parent="382" relname="joint"/>
		<group id="379" type="span" parent="383" relname="span"/>
		<group id="380" type="span" parent="381" relname="span"/>
		<group id="381" type="span" parent="450" relname="joint"/>
		<group id="382" type="multinuc" parent="379" relname="span"/>
		<group id="383" type="span" parent="450" relname="joint"/>
		<group id="384" type="span" parent="240" relname="joint"/>
		<group id="385" type="span" parent="249" relname="joint"/>
		<group id="386" type="span" parent="385" relname="span"/>
		<group id="390" type="span" parent="393" relname="span"/>
		<group id="391" type="multinuc" parent="65" relname="elaboration"/>
		<group id="392" type="span" parent="64" relname="elaboration"/>
		<group id="393" type="span" parent="289" relname="joint"/>
		<group id="394" type="multinuc" parent="75" relname="elaboration"/>
		<group id="395" type="span" parent="396" relname="span"/>
		<group id="396" type="span" parent="289" relname="joint"/>
		<group id="397" type="span" parent="286" relname="span"/>
		<group id="398" type="span" parent="397" relname="elaboration"/>
		<group id="399" type="span" parent="121" relname="elaboration"/>
		<group id="401" type="span" parent="312" relname="joint"/>
		<group id="402" type="span" parent="324" relname="joint"/>
		<group id="403" type="span" parent="402" relname="span"/>
		<group id="404" type="span" parent="433" relname="span"/>
		<group id="405" type="multinuc" parent="328" relname="elaboration"/>
		<group id="406" type="span" parent="446" relname="preparation"/>
		<group id="409" type="span" parent="405" relname="joint"/>
		<group id="410" type="multinuc" parent="337" relname="joint"/>
		<group id="411" type="span" parent="336" relname="span"/>
		<group id="412" type="span" parent="414" relname="span"/>
		<group id="414" type="span" relname="antithesis"/>
		<group id="416" type="span" parent="417" relname="span"/>
		<group id="417" type="span" relname="antithesis"/>
		<group id="418" type="span" parent="358" relname="joint"/>
		<group id="419" type="span" parent="418" relname="span"/>
		<group id="420" type="span" parent="421" relname="same-unit"/>
		<group id="421" type="multinuc" parent="380" relname="preparation"/>
		<group id="422" type="span" parent="423" relname="span"/>
		<group id="423" type="span" parent="424" relname="span"/>
		<group id="424" type="span" parent="249" relname="joint"/>
		<group id="425" type="span" parent="268" relname="span"/>
		<group id="426" type="span" parent="275" relname="joint"/>
		<group id="427" type="span" parent="89" relname="elaboration"/>
		<group id="428" type="span" parent="253" relname="joint"/>
		<group id="429" type="multinuc" parent="260" relname="comparison"/>
		<group id="430" type="span" parent="275" relname="joint"/>
		<group id="431" type="span" parent="306" relname="preparation"/>
		<group id="432" type="span" parent="307" relname="span"/>
		<group id="433" type="span" parent="318" relname="joint"/>
		<group id="434" type="span" parent="435" relname="span"/>
		<group id="435" type="span" parent="319" relname="joint"/>
		<group id="436" type="span" parent="361" relname="elaboration"/>
		<group id="437" type="span" parent="368" relname="evaluation"/>
		<group id="438" type="span" parent="324" relname="joint"/>
		<group id="439" type="span" parent="438" relname="span"/>
		<group id="440" type="span" parent="409" relname="span"/>
		<group id="441" type="span" parent="345" relname="joint"/>
		<group id="442" type="span" parent="441" relname="span"/>
		<group id="443" type="multinuc" parent="444" relname="joint"/>
		<group id="444" type="multinuc" parent="205" relname="condition"/>
		<group id="445" type="span" parent="446" relname="span"/>
		<group id="446" type="span" parent="447" relname="span"/>
		<group id="447" type="span" parent="336" relname="evidence"/>
		<group id="448" type="multinuc" parent="351" relname="joint"/>
		<group id="449" type="span" parent="448" relname="same-unit"/>
		<group id="450" type="multinuc" parent="451" relname="span"/>
		<group id="451" type="span" parent="452" relname="span"/>
		<group id="452" type="span" relname="antithesis"/>
  </body>
</rst>